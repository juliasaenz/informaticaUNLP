# resumen/ Ingenier√≠a de Software

# 1. Conceptos de Software

<aside>
ü§ñ El ******************software****************** refiere a instrucciones (programas de c√≥mputo), procedimientos, reglas, documentaci√≥n y datos asociados que forman parte de las operaciones de un sistema de computaci√≥n

</aside>

---

## **1.1. Caracter√≠sticas del software**

- Es un elemento l√≥gico
- Se desarrolla, no se fabrica
- No envejece ni se desgasta
- No sigue una curva de envejecimiento cl√°sica

******Envejecimiento del Software****** 

![Untitled](Untitled.png)

## 1.2. Tipos de productos de software

Los productos **************************generalizados************************** son sistemas aislados producidos por organizaciones desarrolladoras de software que se venden a un mercado abierto

Los productos ****************************personalizados**************************** son sistemas requeridos por un cliente en particular, con necesidades espec√≠ficas

---

Cada vez m√°s los sistemas se construyen como productos personalizados que parten de un producto generalizado

## 1.3. Participantes en el desarrollo de software

1. **Clientes ejecutivos**: patrocinan el desarrollo del sistema
    1. Proporciona financiamiento a Desarrolladores
2. **Usuarios**: utilizan el sistema
    1. Tiene necesidades 
3. **Desarrolladores**: construyen el sistema
    1. Tiene obligaciones contractuales con Clientes
    2. Proporciona el sistema de software a Usuarios

## 1.4. Ingenier√≠a de software

<aside>
ü§ñ La **********************************************ingenier√≠a de software********************************************** es una disciplina de la ingenier√≠a que comprende todos los aspectos de la producci√≥n de software, desde las etapas iniciales de la especificaci√≥n del sistema incluyendo la evoluci√≥n de este luego de que se comienza a ejecutar

</aside>

Que sea una disciplina de la ingenier√≠a significa que se aplican teor√≠as, m√©todos y herramientas para que las cosas funciones

Que incluya todos los aspectos de la producci√≥n de software significa que, adem√°s de los procesos t√©cnicos de desarrollo de software, comprende actividades de gesti√≥n de proyectos y herramientas y la aplicaci√≥n de t√©cnicas y m√©todos de apoyo

******************************Caracter√≠sticas******************************

- Usa m√©todos sistem√°ticos cuantificables
    - La cuantificaci√≥n rigurosa de recursos, procesos y productos es una precondici√≥n para optimizar productividad y calidad. La ‚Äúmetrificaci√≥n‚Äù y el control estad√≠stico de procesos son claves en Ingenier√≠a de Software.
- Dentro de tiempos y costos estim√°dos
    - Un Ingeniero de Software debe cumplir contratos en tiempo y costos como es normal en obras de Ingenier√≠a. Ello presupone la capacidad de medir, estimar, planificar y administrar proyectos
- Para el desarrollo, operaci√≥n y mantenimiento
    - La Ingenier√≠a de Software se ocupa de todo el ciclo de vida de un producto, desde su etapa inicial de planificaci√≥n y an√°lisis de requerimientos hasta la estrategia para determinar cu√°ndo y c√≥mo debe ser retirado de servicio

## 1.5. El ingeniero de software

¬øQu√© conocimientos debe tener?

- **********************************************Tecnolog√≠as y productos**********************************************
    - Sistemas operativos, lenguajes, bases de datos, sistemas generadores de interfaces, etc
- ******************************************************************************T√©cnicas de administraci√≥n de proyectos******************************************************************************
    - Planificaci√≥n, an√°lisis de riesgo, control de calidad, seguimiento de proyectos, etc

********************************************************************Responsabilidad profecional y √©tica********************************************************************

La Ingenier√≠a de Software se desarrolla en un marco econ√≥mico, social y legal, por lo tanto, los IS deben aceptar responsabilidades m√°s amplias que las responsabilidades t√©cnicas. No debe utilizar su capacidad y habilidades de forma deshonesta, o de forma que deshonre la profesi√≥n

- ********************************Confidencialidad********************************: Respetar la confidencialidad de sus empleados y clientes
- **********************Competencia**********************: No falsificar el nivel de competencia y aceptar responsabilidades fuera de su capacidad
- ********************Derechos de propiedad intelectual********************: Conocer la leyes vigentes sobre las patentes y copyright
- ****Uso inapropiado de las computadoras:**** No debe utilizar sus habilidades t√©cnicas para utilizar de forma inapropiada otras computadoras

# 2. Proceso de Software

<aside>
ü§ñ Un **************************************proceso de software************************************** es un conjunto de actividades y resultados asociados que definen un producto de software

</aside>

Las actividades fundamentales en el proceso de software son la especificaci√≥n, el desarrollo, la validaci√≥n y la evoluci√≥n

<aside>
ü§ñ Un ******modelo de proceso de software****** es una representaci√≥n simplificada de un proceso de software que presenta una visi√≥n de ese proceso. Puede incluir actividades, productos y roles involucrados

</aside>

Es un marco de referencia que contiene los procesos, actividades y tareas involucradas en el desarrollo, explotaci√≥n y mantenimiento de un producto de software, abarcando la vida del sistema desde la definici√≥n de requisitos hasta la finalizaci√≥n de su uso

---

> Modelo de proceso = Paradigma de software = Ciclo de vida del software
> 

El **************************************************ciclo de vida del software************************************************** describe la vida del producto desde su concepci√≥n hasta su implementaci√≥n, entrega, uso y mantenimiento

**************************************Caracter√≠sticas del modelo de proceso**************************************

- Establece todas las actividades
- Usa recursos, est√° sujeto a restricciones y genera productos intermedios y finales
- Puede estar compuesto por subprocesos
- Cada actividad tiene entradas y salidas definidas
- Las actividades se organizan en una secuencia
- Existen principios que orientan sobre las metas de cada actividad
- Las restricciones pueden aplicarse a una actividad, recurso o producto

## 2.1. Tipos de modelos - Seg√∫n el nivel de informaci√≥n

### 2.1.1. Modelos prescriptivos

Prescriben un conjunto de elementos del proceso, se detallan todos los procesos

- Actividades del marco de trabajo
- Acciones de la ingenier√≠a de software
- Tareas
- Aseguramiento de calidad
- Mecanismos de control

Cada modelo de proceso preescribe tambi√©n un ********************************flujo de trabajo********************************, es decir, c√≥mo se interrelacionan los elementos del proceso

### 2.1.2. Modelos descriptivos

Descipci√≥n de la forma en que se realizan en realidad. Es un lineamiento general

## 2.2. Tipos de modelos - Seg√∫n la organizaci√≥n

### 2.2.1. Modelos tradicionales

Est√°n formados por un conjunto de **************************************fases o actividades************************************** en las que no tienen en cuenta la naturaleza evolutiva del sofware. Los m√°s conocidos son:

************************************************************Modelo cl√°sico, l√≠neal o en cascada************************************************************ 

![https://okhosting.com/wp-content/uploads/2015/12/ciclo-de-vida-en-cascada.png](https://okhosting.com/wp-content/uploads/2015/12/ciclo-de-vida-en-cascada.png)

Las etapas se presentan en forma de cascada y cada etapa de desarrollo se debe completar antes de que empiece la siguiente. Es simple de explicar a clientes y √∫til para diagramar lo que se tiene que hacer

Dificultades: No existen resultados concretos hasta que se termine todo el sistema, por lo que las fallas m√°s graves se encuentran al final y necesita m√°s pruebas en las √∫ltimas etapas. Tampoco se adapta f√°cilmente a cambios en el ambiente

**********************Modelo en V**********************

![Untitled](Untitled%201.png)

Demuestra c√≥mo se relacionan las actividades de prueba con las de an√°lisis y dise√±o. Sigiere que la prueba unitaria y de integraci√≥n se use tambi√©n para verificar el dise√±o

La vinculaci√≥n entre los lados derecho e izquierdo hace que si se encuentran problemas durante la verificaci√≥n y validaci√≥n, se pueda volver a ejecutar el lado izquierdo para solucionar el problema

****************************************Modelo basado en prototipos****************************************

![Untitled](Untitled%202.png)

Un **********prototipo********** es un producto parcialmente desarrollado que permite a clientes y desarrolladores examinar aspectos del sistema y tomar decisiones al respecto. Es una alternativa a la especificaci√≥n para tratar de reducir la incertidumbre, ambig√ºedad y volubilidad de los proyectos reales

Se pueden usar ******************************************prototipos evolutivos****************************************** (funcionales) o ************************descartables************************ (no funcionales, usados para modelar)

![Untitled](Untitled%203.png)

Para asegurar el √©xito, debe ser un sistema con el que se pueda experimentar, barato, de desarrollo r√°pido, que haga √©nfasis en la interfaz del usuario y use las herramientas y lenguajes adecuados

### 2.2.2. Modelos evolutivos

Son modelos que se adaptan a la evoluci√≥n que sufren los requisitos del sistema en funci√≥n del tiempo. 

****************************************Desarrollo por fases****************************************

Se desarrolla el sistema de tal manera que pueda ser entregado en piezas. Esto implica que existen dos sistemas funcionando en paralelo: el **************************************sistema operacional************************************** y el ******************************************sistema en desarrollo******************************************

![Untitled](Untitled%204.png)

Hay varios tipos de modelos de desarrollo por fases:

**********************Incremental**********************

El sistema es particionado en subsistemas de acuerdo con su funcionalidad. Cada entrega agrega un subsistema

---

******************Iterativo******************

Entrega un sistema completo desde el principio y luego aumenta la funcionalidad de cada subsistema con las nuevas versiones

---

******************En espiral******************

Trata de mejorar los ciclos de vida cl√°sicos y prototipos, incorpora objetivos de calidad, elimina errores y alternativas al comienzo, permite iteraciones y finalizaciones r√°pidas

Cada ciclo se completa con una revisi√≥n que incluye el ciclo anterior y el plan para el siguiente

![Untitled](Untitled%205.png)

**Basado en componentes** 

Esta t√©cnica supone que las partes ya existen, el proceso se enfoca entonces en la integraci√≥n de esas partes

![Untitled](Untitled%206.png)

### 2.2.3. Modelos intermedios

**************************************Desarrollo Basado en Modelos MBD**************************************

Un ************************************modelo del sistema************************************ consiste en una conceptualizaci√≥n del dominio del problema y act√∫a como una especificaci√≥n precisa de los requerimientos que el sistema de software debe satisfacer (abstracci√≥n de elementos del problema, comunicaci√≥n, negociaci√≥n con el usuario)

![Untitled](Untitled%207.png)

**************************************Desarrollo Dirigido por Modelos MDD**************************************

El adjetivo ********dirigido******** enfatiza que el paradigma asigna a los modelos un rol central y activo: son al menos tan importantes como el c√≥digo fuente

El **Model Driven Development** (MDD) enfatiza en:

- Mayor nivel de abstracci√≥n en la especificaci√≥n del problema y la soluci√≥n
- Aumento de confianza en la automatizaci√≥n asistida por computadora para el an√°lisis, dise√±o y ejecuci√≥n
- Uso de est√°ndares industriales para facilitar comunicaciones, interacci√≥n entre aplicaciones y productos y especializaci√≥n tecnol√≥gica
- Los modelos son los conductores primarios en todos los arpectos del desarrollo de software

---

Los **************modelos************** pasan a ser entidades contemplativas a entidades productivas a partir de las cuales se deriva la implementaci√≥n en forma autom√°tica

![Untitled](Untitled%208.png)

---

**********************************************************************************************Ciclo de vida del software dirigido por modelos********************************************************************************************** 

![Untitled](Untitled%209.png)

---

**************************************************Pasos principales en el proceso de desarrollo MDD************************************************** 

![Untitled](Untitled%2010.png)

- ******PIM (Nivel 1)******: Un modelo de un sistema que no tiene informaci√≥n sobre la plataforma o tecnolog√≠a a usar
- **************************PSM (Nivel 2)**************************: Un modelo de un sistema que incluye informaci√≥n acerca de la tecnolog√≠a espec√≠fica a usar
- **************************************************Transformaci√≥n de modelos**************************************************: Especifica el proceso de conversi√≥n de un modelo a otro
Cada transformaci√≥n incluye:
    - un PIM
    - un Modelo de la Plataforma
    - una Transformaci√≥n
    - un PSM

---

********************************Transformaciones******************************** 

<aside>
ü§ñ Una ********transformaci√≥n******** consiste en una colecci√≥n de reglas espec√≠ficas de las formas en que un modelo puede ser usado para crear otro modelo

</aside>

![Untitled](Untitled%2011.png)

---

****************************Ejemplo de una transformaci√≥n****************************

![Untitled](Untitled%2012.png)

---

**********************************Beneficios de MDD********************************** 

- Incremento en la productividad
- Adaptaci√≥n a los cambios tecnol√≥gicos
- Adaptaci√≥n a los cambios de requisitos
- Consistencia (automatizaci√≥n)
- Re-uso de modelos y transformaciones
- Mejoras en la comunicaci√≥n con los usuarios y entre desarrolladores
- Captura de la experiencia
- Los modelos son productos de larga duraci√≥n
- Posibilidad de demorar decisiones tecnol√≥gicas

### 2.2.4. Procesos √°giles

********ver en [5. Metodolog√≠as √Ågiles](https://www.notion.so/5-Metodolog-as-giles-203bd4dcd719429591d5596029c1678e)* 

## 2.3. An√°lisis Estructurado

Es un **************************modelo de procesos tradicional y completo************************** porque incluye una t√©cnica de especificaci√≥n espec√≠fica

Para entender los requerimientos, hay que poder entender c√≥mo se mueven los datos, procesos y transformaciones que sufren los datos y sus resultados. La **********************elicitaci√≥n********************** proporciona una descripci√≥n verbal del sistema, pero una descripci√≥n visual ayuda a consolidar la informaci√≥n

<aside>
ü§ñ El ************************************an√°lisis estructurado************************************ define una representaci√≥n gr√°fica que permite lograr una comprensi√≥n m√°s profunda del sistema a construir y comunicarlo a los usuarios

</aside>

Hace enf√°sis en la transformaci√≥n de los datos a medida que pasan por distintos procesos y la notaci√≥n no espec√≠fica de aspectos f√≠sicos de implementaci√≥n

### 2.3.1. Diagrama de flujo de datos (DFD)

El ****************************************************diagrama de flujo de datos**************************************************** es una herramienta que permite ver un sistema como una red de procesos funcionales, conectados entre si por conductos y almacenamiento de datos

Tambi√©n se llama ‚Äúdiagrama de burb√∫jas‚Äù

- Uso com√∫n: sistemas operacionales con funciones complejas

********Componentes********

- ******************************Entidad externa [******************************rect√°ngulo]: Un elemento del sistema (hardware, persona, otro programa) que produce o recibe informaci√≥n
- ******************************************************************Proceso o transformaci√≥n de datos****************************************************************** [c√≠culo o burbuja]
- **********************************Elemento de datos********************************** [flecha]
- ********************************Almac√©n de datos******************************** [rect√°ngulo abierto]

![Ejemplo de DFD](Untitled%2013.png)

Ejemplo de DFD

************************************Desarrollo de DFDs************************************

Se debe ver desde una perspectiva jer√°rquica de arriba hacia abajo.

Pasos:

1. Redactar la ****************************************lista de actividades**************************************** de la organizaci√≥n para determinar entidades externas, flujos de datos, procesos y almacenes de datos
2. Crear un ****************************************diagrama de contexto**************************************** que muestre las entidades externas y los flujos de datos desde y hacia el sistema
3. Dibujar el ********************diagrama 0******************** (siguiente nivel) con procesos generales y almacenes correspondientes
4. Dibujar un **************************diagrama hijo************************** por cada uno de los procesos del diagrama 0

****************************************Diagrama en contexto****************************************

Muestra un panorama global con las entradas y salidas b√°sicas, es el nivel m√°s alto de un DFD y contiene un solo proceso que representa todo el sistema

![Untitled](Untitled%2014.png)

**************Nivel 0**************

Es la ampliaci√≥n del diagrama de contexto, las entradas y salidas permanecen pero se ampl√≠a hasta incluir 9 procesos y mostrar almacenes de datos y nuevos flujos

![Untitled](Untitled%2015.png)

****************************************Nivelaci√≥n de un DFD****************************************

Cada proceso se puede ampliar apra crear un diagrama hijo m√°s detallado; permaneciendo las entradas y salidas del proceso padre pero pudiendo aparecer nuevos almacenes y flujos.

![Untitled](Untitled%2016.png)

# 3. Ingenier√≠a de Requerimientos

Al iniciar un proyecto, la primera actividad es saber lo que el usuario quiere, c√≥mo, cu√°ndo y por qu√©. La ************************comunicaci√≥n************************ es la base para la obtenci√≥n de necesidades del cliente. En t√©rminos m√°s t√©cnicos, cuando hablamos de necesidades en realidad hablamos de ****************************requerimientos****************************

<aside>
ü§ñ La ********************************************************ingenier√≠a de requerimientos******************************************************** es el proceso por el cual se transforman los requerimientos del cliente a especificaciones precisas, consistentes y completas del comportamiento del sistema

</aside>

Tambi√©n es el proceso mediante el cual se intercambian diferentes puntos de vista para recopilar y modelar lo que el sistema va a hacer. Este proceso usa una combinaci√≥n de m√©todos, herramientas y actores cuyo producto es un modelo a partir del cual se crea un ******************************************************documento de requerimientos******************************************************

Es un enfoque sistem√°tico para recolectar, organizar y documentar los requerimientos del sistema; es tambi√©n el proceso que establece y mantiene acuerdos sobre los cambios de requerimientos entre los clientes y el equipo del proyecto

******************************************************************************************Importancia de la ingenier√≠a de requerimientos******************************************************************************************

- Permite gestionar las necesidades del proyecto de forma estructurada
- Mejora la capacidad de predecir el cronograma del proyecto
- Disminuye costos y retrasos
- Mejora la calidad del software
- Mejora la comunicaci√≥n entre equipos
- Evita rechazos de usuarios finales

## 3.1. Requerimientos

<aside>
ü§ñ Un requerimiento (o requisito) es una caracter√≠stica del sistema o una descripci√≥n de algo que el sistema es capaz de hacer con el objeto de satisfacer el prop√≥sito del sistema

</aside>

**********************************************Definici√≥n IEEE-Std-610**********************************************

- Condici√≥n o capacidad que necesita el usuario para resolver un problema o alcanzar un objetivo
- Condici√≥n o capacidad que debe satisfacer un sistema para satisfacer un contrato, est√°ndar, especificaci√≥n o documento formal
- Representaci√≥n documentada de una condici√≥n o capacidad

******************Objetivos******************

- Permitir que los desarrolladores expliquen c√≥mo han entendido lo que el cliente pretende del sistema
- Indicar a los dise√±adores qu√© funcionalidades y caracter√≠sticas va a tener el sistema resultante
- Indicar al equipo de pruebas qu√© demostraciones llevar a cabo para convencer al cliente de que el sistema que se le entrega es acorde a lo pedido

************************************************************************************************Impacto de errores en la etapa de requerimientos************************************************************************************************

- El software resultante puede no satisfacer a los usuarios
- Las interpretaciones de los requerimientos pueden causar desacuerdos entre clientes y desarrolladores
- Puede gastarse tiempo y dinero construyendo un sistema erroneo

********************************************Fuentes de requerimientos******************************************** 

- Documentaci√≥n
- ************************Stakeholders************************: Cualquier persona o grupo que se ver√° afectado directa o indirectamente por el sistema
- Especificaciones de sistemas similares

### **********************************************3.1.1. Tipos de requerimientos**********************************************

Los ****************************************************requerimientos funcionales**************************************************** describen una interacci√≥n entre el sistema y su ambiente, c√≥mo debe comportarse ante determinados est√≠mulos. Describen lo que el sistema debe hacer o como no debe comportarse.

Describen en detalle la funcionalidad del mismo, son independientes de la implementaci√≥n de la soluci√≥n y como tal, pueden expresarse en formas distintas

---

Los ****************************requerimientos**************************** ****************************no funcionales**************************** describen una restricci√≥n sobre el sistema que limita nuestras elecciones en la construcci√≥n de la soluci√≥n al problema. Dentro de este tipo existen varias categor√≠as:

- ******Requerimientos del producto******, que especifican el comportamiento del producto (usabilidad, eficiencia, rendimiento, espacio, fiabilidad, portabilidad)
- **************************************************************Requerimientos organicacionales**************************************************************, que se derivan de las pol√≠ticas y procedimientos existentes en la organizaci√≥n del cliente y en la del desarrollador (entrega, implementaci√≥n, est√°ndares)
- **********************************************Requerimientos externos**********************************************, que pueden referir a requerimientos de interoperabilidad, legales, de privacidad, seguridad o √©ticos

![√Årbol de requerimientos no funcionales y sus sub categor√≠as](Untitled%2017.png)

√Årbol de requerimientos no funcionales y sus sub categor√≠as

Existen tambi√©n otras clasificaciones que no se adhieren estrictamente a las categor√≠as anteriores: 

- ************************************Requerimientos del dominio************************************, que reflejan las caracter√≠sticas y restricciones del dominio de la aplicaci√≥n del sistema.  Pueden ser funcionales o no y pueden restringir anteriores requerimientos
- ******Requerimientos por prioridad******, seg√∫n si un requerimiento debe ser satisfecho, si es deseable pero no necesario o si es posible pero descartable
- ****************************************************Requerimientos del usuario****************************************************, refiere a declaraciones en lenguaje natural y en diagramas de los servicios que se espera que el sistema provea y de las restricciones bajo las cuales debe operar
- ****************************************************Requerimientos del sistema****************************************************, que establecen con detalle los servicios y restricciones del sistema.

---

## 3.2. Puntos de vista

Existen 3 tipos gen√©ricos de puntos de vista

El punto de vista de los ******************************interactuadores****************************** representa a las personas o sistemas que interactuan directamente con el sistema

El punto de vista ******************indirecto****************** representa a los stakeholders que no usan el sistema directamente pero influyen en sus requerimientos

El punto de vista del **************dominio************** representa las caracter√≠sticas y restricciones del dominio que influyen en los requerimientos del sistema

---

La identificaci√≥n de un punto de vista puede ser dif√≠cil, algunos de los m√°s espec√≠ficos son:

- Proveedores y receptores de servicios del sist.
- Desarrolladores y  administradores del sistema
- Marketing
- Los sist. que interactuan con el nuestro
- Las regulaciones y est√°ndares
- Las fuentes de requerimientos

## 3.3. Elicitaci√≥n de requerimientos

<aside>
ü§ñ La **********************************************************elicitaci√≥n de requerimientos********************************************************** es el proceso de adquirir todo el conocimiento relevante para producir un modelo de los requerimientos de un dominio de problema

</aside>

La elicitaci√≥n busca conocer el dominio del problema para poder comunicarse con clientes y usuarios; conocer el sistema actual; e identificar las necesidades tanto impl√≠citas como expl√≠citas de los usuarios

En el proceso pueden aparecer **************************************************problemas de comunicaci√≥n************************************************** seg√∫n las limitaciones cognitivas del desarrollador, por cuestiones de conducta humana o t√©cnicos

## 3.4. T√©cnicas de elicitaci√≥n

### ************************************************3.4.1. M√©todos discretos************************************************

**********************************Muestreo**********************************

Muestreo de la documentaci√≥n, formularios y datos existentes. Recolecci√≥n de los hechos a partir de la documentaci√≥n disponible. Permite reconocer el historial del proyecto

---

**********Investigaci√≥n y visitas al lugar**********

Investigar el dominio, patrones de soluciones y problemas similares

---

****************************************************************Observaci√≥n del ambiente de trabajo****************************************************************

Con consentimiento, tomando nota y sin interrumpir el flujo normal de trabajo

### ******************************************************3.4.2. M√©todos interactivos******************************************************

**************************Cuestionarios**************************

Recolectar datos de muchas personas, sentimientos generalizados y problemas entre usuarios

---

**********************Entrevistas**********************

Una conversaci√≥n con prop√≥sito espec√≠fico basado en preguntas y respuestas

---

**************************************************************************Planeaci√≥n conjunta de requerimientos**************************************************************************

JRP ‚Üí proceso mediante el cual se conducen reuniones de grupo altamente estructuradas con el prop√≥sito de analizar problemas y definir requerimientos

---

********Branistorming********

T√©cnica para generar ideas que alienta a los participantes a ofrecer tantas ideas como sea posible en poco tiempo, sin importar la calidad 

## 3.5. Estudio de viabilidad

***********************************Principalmente para sistemas nuevos***********************************

A partir de una descripci√≥n resumida del sistema, se elabora un informe que recomienda la conveniencia o no de realizar el proceso de desarrollo. Responde a las preguntas:

- ¬øEl sistema contribute a los objetivos generales de la organizaci√≥n?
- ¬øEl sistema se puede implementar con la tecnolog√≠a actual?
- ¬øEl sistema se puede implementar con las restriccioens de costo y tiempo?
- ¬øEl sistema puede integrarse a otros que existen en la organizaci√≥n?

## 3.6. Especificaci√≥n de requerimientos

Algunas propiedades que deben tener los requerimientos (hay m√°s):

- **Necesarios**: Su omisi√≥n provoca deficiencia
- **Consisos**: F√°ciles de leer y entender
- **Completos**: No necesitan ampliarse
- ******************No ambiguo******************: Tiene una sola interpretaci√≥n
- **********************Verificable**********************: Puede testearse a trav√©s de inspecciones o pruebas

********************Documentos********************

El **********************************************************************************documento de definici√≥n de requerimientos********************************************************************************** es un listado completo de todas las cosa que el cliente espera que haga el sistema

El ******************************************************************************************documento de especificaci√≥n de requerimientos****************************************************************************************** es la definici√≥n en t√©rminos t√©cnicos de lo planteado en el documento de definici√≥n

El ******************************************************************************************************************************************************************documento de especificaci√≥n de requerimientos de software IEEE Std 830-1998 (SRS)****************************************************************************************************************************************************************** busca brindar una colecci√≥n de buenas pr√°cticas para escribir especificaciones de requerimientos de software. Se describen los contenidos y las cualidades de una buena especificaci√≥n de requerimientos

****************************************************************************************************************Aspectos b√°sicos de una especificaci√≥n de requerimientos****************************************************************************************************************

- **************************Funcionalidad**************************: Qu√© deber√≠a hacer el software
- **************************************Interfaces externas**************************************: C√≥mo interactua el software con el medio externo (gente, hardware, otros softwares)
- **********************Rendimiento**********************: La velocidad, disponibilidad, tiempo de respuesta, etc
- ******************Atributos******************: Portabilidad, seguridad, mantenibilidad, eficiencia
- **********************************************Restricciones de dise√±o**********************************************: Est√°ndares requeridos, lenguaje, l√≠mite de recursos, etc

### 3.6.1. Usuarios de un documento de requerimientos

- ****************************************Clientes del sistema****************************************: Especifican los requerimientos y los leen para comprobar que cubren sus necesidades. Los clientes especifican los cambios a los requisitos
- ******************************Administradores******************************: Usan el documento de requerimientos para plantear una cotizaci√≥n para el sistema y el proceso del desarrollo del sistema
- ********************************************Ingenieros del sistema********************************************: Usan los requerimientos para entender qu√© sistema debe desarrollarse
- ****************************************************************Ingenieros de prueba del sistema****************************************************************: Usan los requerimienos para desarrollar pruebas de validaci√≥n para el sistema
- ******************************************************************************Ingenieros de mantenimiento del sistema******************************************************************************: Usan los requerimientos para comprender el sistema y las relaciones entre sus componentes

## 3.7. Validaci√≥n de requerimientos

<aside>
ü§ñ La ****************************************************validaci√≥n de requerimientos**************************************************** es el proceso de certificar la correcci√≥n del modelo de requerimientos contra las intenciones del usuario. Trata de mostrar que los requerimientos definidos est√°n en el sistema

</aside>

- ********************Validaci√≥n********************: Al final del desarrollo evaluar el software para asegurar que cumple con los requerimientos
- ************************Verificaci√≥n************************: El software cumple con los requerimientos correctamente

---

La validaci√≥n de requerimientos comprende verificar la validez para todos los usuarios, la consistencia del sistema, la completitud de los requerimientos, el realismo y la verificabilidad

### 3.7.1. T√©cnicas de validaci√≥n

***********************************Pueden ser manuales o automatizadas***********************************

- Revisiones de requerimientos
    - Informales: los desarrolladores deben tratar los requerimientos con tantos stakeholders como sea posible
    - Formales: el equipo de desarrollo debe conducir al cliente, explic√°ndole las implicaciones de cada requerimiento
- Construcci√≥n de prototipos
- Generaci√≥n de casos de prueba

# 4. T√©cnicas de Especificaci√≥n de Requerimientos

Las t√©cnicas de especificaci√≥n de requerimientos pueden dividirse en dos tipos: est√°ticas y din√°micas.

Las ******************est√°ticas****************** describen el sistema a trav√©s de entidades u objetos, sus atributos y sus relaciones con otros. No describe c√≥mo las relaciones cambian con el tiempo. Se suelen usar cuando el tiempo no es un factor relevante en la operaci√≥n del sistema

***[ Ejemplos: Referencia indirecta, relaciones de recurrencia, definici√≥n axiom√°tica, expresiones regulares, abstracciones de datos, etc ]***

- Historias de usuario
- Casos de uso

Las ******************din√°micas****************** consideran un sistema en funci√≥n de los cambios que ocurren a lo largo del tiempo. Se considera que el sistema est√° en un estado particular hasta que un est√≠mulo lo obliga a cambiar de estado

***********[ Ejemplos: Tablas de decisi√≥n, diagramas de transici√≥n de estados, tablas de transici√≥n de estados, diagramas de persianas, diagramas de transici√≥n extendidos, redes de petri, etc ]***********

- Diagrama de transici√≥n de estados
- Redes de petri

## 4.1. Historias de Usuario

<aside>
ü§ñ Una **historia de usuario** es una representaci√≥n de un requisito de software escrito en una o dos fases utilizando el lenguaje com√∫n del usuario

</aside>

Debe ser **limitada**, debe poder escribirse sobre una nota adhesiva peque√±a, ya que son una forma r√°pida de amdministrar los requisitos de los usuarios sin tener que elaborar una gran cantidad de documentos formales

Permiten responder r√°pidamente a los requisitos cambiantes

Al momento de implementar las historias, los desarrolladores deben poder discutirlas con los clientes. Generalmente se estima el tiempo de cada historia entre 10 horas y un par de semanas; estimaciones mayores a 2 semanas son indicativo que la historia es muy compleja y debe ser dividida

******************************Caracter√≠sticas******************************

- Son **independientes unas de otras**
- Son **negociables**: si la historia no es lo suficientemente expl√≠cita, se debe esclarecer mediante discusi√≥n con usuarios
- Son **valoradas por los clientes o usuarios**: cada historia debe ser importante para alguno de ellos
- Son **estimables**: la discusi√≥n de una historia de usuario es la estimaci√≥n del tiempo que tomar√° completarla
- Son **peque√±as**
- Son **verificables**: cubren requerimientos funcionales, por lo que pueden verificarse. Cuando sea posible la verificaci√≥n debe automatizarse

![Untitled](Untitled%2018.png)

![Untitled](Untitled%2019.png)

**Beneficios** 

- Representa requisitos del modelo de negocio que pueden implementarse r√°pidamente
- Necesitan poco mantenimiento
- Mantienen una relaci√≥n cercana con el cliente
- Permite dividir los proyectos en peque√±as entregas
- Permite estimar f√°cilmente el esfuerzo de desarrollo
- Es ideal para proyectos con requisitos vol√°tiles o no muy claros

**Limitaciones** 

- Sin criterios de aceptaci√≥n pueden quedar abiertas a diferentes interpretaciones
- Se requiere un contrato permanente con el cliente durante el proyecto
- Puede resultar dif√≠cil escalar a proyectos grandes
- Requiere desarrolladores muy competentes

## 4.2. Casos de Uso

<aside>
ü§ñ Un **********************caso de uso********************** es un proceso de modelado de las ‚Äúfuncionalidades‚Äù del sistema en t√©rmino de los eventos que interact√∫an entre los usuarios y el sistema

</aside>

********************Beneficios********************

- Herramienta para caturar requerimientos funcionales
- Descompone el alcance del sistema en piezas m√°s manejables
- Medio de comunicaci√≥n con los usuarios
- Usa el lenguaje com√∫n
- Permite estimar el alcance del proyecto y el esfuerzo a realizar
- Define una l√≠nea base para la definici√≥n de los planes de prueba
- Define una l√≠nea base para toda la documentaci√≥n del sistema
- Proporciona una herramienta para el seguimiento de los requisitos

**********************Componentes**********************

- ****************Diagrama****************
    - **Casos de uso**
        - El CU representa un objetivo (funcionalidad) individual del sistema y describe la secuencia de actividades y de interacciones para alcanzarlo.
        - Para que el CU sea considerado un requerimiento debe estar acompa√±ado de su respectivo escenario
    - **Actores**
        - Un actor inicia una actividad (CU) en el sistema
        - Representa un papel desempe√±ado por un usuario que interact√∫a (rol)
        - Puede ser una persona, sistema externo o dispositivo externo que dispare un evento (sensor, reloj, etc)
    - **Relaciones**
        - Asociaciones
            - Relaci√≥n entre un actor y un CU en el que interactuan entre s√≠
        - Extensiones (*Extends)*
            - Un CU entiende la funcionalidad de otro CU
            - Un CU puede tener muchos CU extensiones
            - Los CU extensiones s√≥lo son iniciados por un CU
        - Uso o inclusi√≥n (*Uses)*
            - Reduce la redundancia entre dos o m√°s CU al combinar los pasos com√∫nes de los CU
        - Dependencia (*Depends)*
            - Relaci√≥n entre CU que indica que un CU no puede realizarse hasta que se haya realizado otro CU
        - Herencia
            - Relaci√≥n entre actores donde un actor hereda las funcionalidades de uno o varios actores
- ******************Escenario******************
    - **Nombre del CU**
        - <verbo> ‚Äî Debe representar la meta del CU
    - **ID del CU**
    - **Otros actores participantes**
        - Actor principal que se beneficia del CU
        - Otros actores que intervienen en el CU
    - **Descripci√≥n**
        - Una descripci√≥n corta y precisa del prop√≥sito del CU
    - **Precondici√≥n**
        - Una restricci√≥n del estado del sistema antes de la ejecuci√≥n del CU
    - **Curso t√≠pico de eventos**
        - Secuencia normal realizada por los actores y el sistema
        - Debe representar la interacci√≥n entre el actor y el sistema
    - **Cursos alternos**
        - Describen el comportamiento si ocurra una excepci√≥n o variaci√≥n del curso t√≠pico
    - **Postcondici√≥n**
        - Restricci√≥n del estado del sistema despu√©s de la finalizaci√≥n exitosa del CU

******************************************************Caracter√≠sticas importantes******************************************************

- Un CU debe representar una funcionalidad concreta
- La descripci√≥n de los pasos en los escenarios debe contener m√°s de un paso, para representar la interacci√≥n entre los componentes
- El uso de condicionales en el curso normal, es limitado a la invocaci√≥n de excepciones, ya que este flujo representa la ejecuci√≥n del caso sin alteraciones
- Las pre-condiciones no deben representarse en los cursos alternativos, ya que al ser una pre-condici√≥n no va a ocurrir
- Los ‚Äúuses‚Äù deben ser accedidos por lo menos desde dos CU

## 4.3. Diagrama de Transici√≥n de Estados

<aside>
ü§ñ Un ******************************************************************diagrama de transici√≥n de estados****************************************************************** describe al sistema como un conjunto de estados donde el sist. reacciona a ciertos eventos posibles

</aside>

![Untitled](Untitled%2020.png)

**Construcci√≥n de un DTE** 

1. Identificar los estados
2. Si hay un estado complejo se puede explotar
3. Desde el estado inicial, se identifican los cambios de estado con flechas
4. Se analizan las condiciones y las accones para pasar de un estado a otro
5. Se verifica la consistencia
    1. Se han definido todos los estados
    2. Se pueden alcanzar todos los estados
    3. Se pueden salir de todos los estados
    4. En cada estado, el sistema responde a todas las condiciones posibles (normales y anormales)

## 4.4. Redes de Petri

Se usan para especificar sistemas de tiempo real en los que son necesarios representar aspectos de **concurrencia**

Los **sistemas concurrentes** se dise√±an para permitir la ejecuci√≥n simult√°nea de componentes de programaci√≥n, llamadas tareas o procesos, en varios procesadores o intercalados en un solo procesador

Las **tareas concurrentes** deben estar sincronizadas para permitir la comunicaci√≥n entre ellas; pueden operar a distintas velocidades, deben prevenir la modificaci√≥n de datos compartidos o condiciones de bloqueo. Pueden realizarse varias tareas en paralelo pero ejecutarse en orden impredecible, por lo que no son secuenciales

**Elementos de una Red de Petri** 

Definici√≥n formal: una estructura de Red de Petri es un 4-upla:

$$
C = (P, T,I,O)
$$

**P (*Places) ‚Äî* Lugares**

- Estados o condiciones

**T (*Transitions) ‚Äî* Transiciones**

- Eventos o acciones

**I (*Input Function) ‚Äî* Funci√≥n de Entrada**

- I: T ‚Üí P

**O *(Output Function) ‚Äî* Funci√≥n de Salida**

- O: T ‚Üí P

**‚Üí Relaciones**

- Los arcos indican la relaci√≥n entre lugares y transiciones

**‚óç (*Tokens) ‚Äî* Fichas**

- A los lugares se les asignan *tokens* que se representan mediante un n√∫mero o puntos dentro de un sitio
- Esta asignaci√≥n de *tokens* a lugares constituye la marcaci√≥n
- Luego de una marcaci√≥n inicial se puede simular la ejecuci√≥n de red
- El n√∫mero de *tokens* asignados a un sitio es ilimitado ****

---

El conjunto de ***tokens*** asociado a cada estado sirve para manejar la coordinaci√≥n de eventos y estados. Una vez que ocurre un evento, un token puede ‚Äúviajar‚Äù de uno de los estados a otro, si es que se cumplen las condiciones adecuadas, las cuales son controladas por el n√∫mero y distribuci√≥n de los *tokens.*

La **ejecuci√≥n** se realiza disparando **transiciones habilitadas**. Una transici√≥n est√° habilitada cuando cada lugar de entrada tiene al menos tantos *tokens* como arcos hacia la transici√≥n

**Disparar una transici√≥n habilitada** implica remover *tokens* de los lugares de entrada y distribuir *tokens* en los lugares de salida. La ocurrencia de los eventos (**transiciones**) depende del estado del sistema. Una **condici√≥n** puede ser V (con *token*) o F (*sin token*). 

La **ocurrencia de un evento** est√° sujeta a que se den ciertas pre-condiciones y al ocurrir un evento causa que se hagan verdaderas las post-condiciones

****Caracter√≠sticas****

- Es importante desarrollar modelos de los sistemas de eventosdiscretos para estudiarlos y comprender su comportamiento
- Existen herramientas computacionales que permiten analizar estetipo de sistemas, las cuales est√°n basadas en an√°lisis estad√≠sticos y ofrecen soluciones con cierts grados de incertidumbre
- Por otro lado, las RdP peuden ser aplicadas para la modelaci√≥n de sistemas de eventos discretos, las cuales ofrecen una forma de representaci√≥n gr√°fica y matem√°tica de los sistemas modelados
- La formalidad matem√°tica de la RdP proporciona herramientas de an√°lisis para los posibles estados a los que el sistema modelado pudiese alcanzar

## 4.5. Tablas de Decisi√≥n

<aside>
ü§ñ Una **************************tabla de decisi√≥n************************** es una herramienta para mostrar las reglas l√≥gicas que definen las acciones a ejecutar en funci√≥n de las condiciones y l√≥gica de decisi√≥n de un problema espec√≠fico

</aside>

Se describe el sistema como un conjunto de posibles **********************condiciones********************** satisfechas por el sistema en un momento dado, ************reglas************ para reaccionar ante los est√≠mulos que ocurren cuando se re√∫nen determinadas condiciones y ************acciones************ a ser tomadas como resultado

| Condiciones y acciones |  | Reglas |  |  |
| --- | --- | --- | --- | --- |
| Es cliente | V | V | F | F |
| Hay stock | V | F | V | F |
| Imprime mensaje de aviso |  |  | X | X |
| Se remite | X |  |  |  |

************************Construcci√≥n de una tabla************************

1. Se identifican las condiciones y acciones a partir del enunciado
2. Se completa la tabla teniendo en cuenta
    1. Si hay condiciones opuestas, colocar solo una
    2. Si hay n condiciones excluyentes, anotar n-1
    3. Las condiciones deben ser at√≥micas
3. Se construyen las reglas

**************************************************Tipos de especificaciones**************************************************

Las ********especificaciones completas******** son aquellas que determinan acciones para todas las reglas posibles (as√≠ tiene que ser la tabla)

Las ********************************************************especificaciones redundantes******************************************************** son aquellas que marcan para condiciones iguales las mismas reglas

Las **************especificaciones contradictorias************** son quellas que para reglas con las mismas condiciones, marcan acciones distintas

************************************************Reducci√≥n de complejidad************************************************

Cuando la alternativa de una condici√≥n no representa una diferencia en el resultado, se pueden combinar las reglas, marcando el campo irrelevante con ‚Äú_‚Äù (gui√≥n)

![Untitled](Untitled%2021.png)

![Untitled](Untitled%2022.png)

# 5. Metodolog√≠as √Ågiles

<aside>
ü§ñ Una ********************************metodolog√≠a √°gil******************************** es aquella en la que se da prioridad a las tareas que dan resultados directos y que reducen la burocracia tanto como sea posible, adapt√°ndose r√°pidamente al cambio de los proyectos

</aside>

Es un enfoque iterativo e incremental (evolutivo) de desarrollo de software

******************Objetivos******************

- Producir software de alta calidad con un costo efectivo y en tiempo apropiado
- Responder r√°pidamente a los cambios que puedan surgir a lo largo del proyecto
- Ofrecer un proceso flexible de desarrollo

**************Valores**************

- ************Individuos e interacciones************ m√°s que procesos y herramientas
- ************************Software******** operante** m√°s que documentaciones completas
- ******************************************************Colaboraci√≥n con el cliente****************************************************** m√°s que negociaciones contractuales
- **************************************Respuesta al cambio************************************** m√°s que apegarse a una rigurosa planificaci√≥n

*No porque se valoren m√°s los conceptos de la izquierda debemos ignorar los de la derecha. Es una definici√≥n de preferencias, no alternativas*

********************Principios********************

1. Nuestra mayor prioridad es satisfacer al cliente a trav√©s de **f√°ciles y continuas entregas** de software valuable.
2. Los **cambios de requerimientos son bienvenidos**, a√∫n tard√≠os, en el desarrollo. Los procesos √Ågiles capturan los cambios para que el cliente obtenga ventajas competitivas.
3. **Entregas frecuentes** de software, desde un par de semanas a un par de meses, con el menor intervalo de tiempo posible entre una entrega y la siguiente.
4. **Usuarios y desarrolladores deben trabajar juntos** durante todo el proyecto.
5. Construir proyectos alrededor de **motivaciones individuales**.
6. Darles el ambiente y el soporte que ellos necesitan y confiar el trabajo dado. El **di√°logo cara a cara** es el m√©todo m√°s eficiente y efectivo de intercambiar informaci√≥n entre el equipo de desarrolladores.
7. El **software que funciona** es la medida clave de progreso.
8. Los procesos √°giles promueven un **desarrollo sostenible**. Los stakeholders, desarrolladores y usuarios deber√≠an ser capaces de mantener un paso constante indefinidamente.
9. **Atenci√≥n** continua a la excelencia t√©cnica y buen dise√±o incrementa la agilidad.
10. **Simplicidad** (el arte de maximizar la cantidad de trabajo no dado) es esencial.
11. Las mejores arquitecturas, requerimientos y dise√±os surgen de la propia **organizaci√≥n de los equipos**.
12. A intervalos regulares, el equipo **reflexiona sobre c√≥mo volverse m√°s efectivo,** entonces afina y ajusta su comportamiento en consecuencia.

******************************************************Comparaci√≥n √°gil vs no √°gil******************************************************

| Metodolog√≠a √Ågil | Metodolog√≠a No √Ågil |
| --- | --- |
| Pocos artefactos | M√°s artefactos |
| Pocos roles | M√°s roles |
| No existe un contrato tradicional o al menos es flexible | Existe un contrato prefijado |
| El cliente es parte del equipo de desarrollo | El cliente interact√∫a con el equipo de desarrollo mediante reuniones |
| Grupos peque√±os ( <10 integrantes) y trabajando en el mismo sitio | Grupos grandes |
| Menos √©nfasis en la arquitectura | La arquitectura es escencial |

**********************Desventajas**********************

- Dificultad de integrar al cliente al equipo
- Dificultad para priorizar cambios
- Dificultad para mantener la simplicidad del sistema
- Para organizaciones grandes, es complejo realizar un cambio de metodolog√≠a de desarrollo
- Complejidad para reglamentar eldocumento de requerimientosdel ********software********
- Es complejo implementarlo para la actualizaci√≥n y mantenimiento de sistemas, en lugar de para el desarrollo

## 5.1. Principales metodolog√≠as √°giles

- XP (*eXtremme Programming)*
- Scrum
- DSDM (***Dynamic Systems Development Method***)
- *********Crystal Methods*********
- ASD (******************************Adaptative Software Development)******************************
- FDD (*******Feature-Driven Development*******)

### 5.1.1. eXtreme Programming

Disciplina de desarrollo de software basada en los valores de la sencillez, la comunicaci√≥n, la retroalimentaci√≥n, la valent√≠a y el respeto

![Untitled](Untitled%2023.png)

******************************************************Caracter√≠sticas escenciales****************************************************** 

- Historias de usuario
- Roles
    - Programador
    - Jefe de proyecto
    - Cliente
    - Entrenador
    - Encargado de pruebas
    - Rastreador
- Proceso
- Pr√°cticas

********************Ciclo de vida******************** 

![Untitled](Untitled%2024.png)

1. **Exploraci√≥n**
    1. Los clientes plantean las historias de usuario de inter√©s
    2. El equipo de desarrollo se familiariza con las herramientas, tecnolog√≠as y pr√°cticas a usar
    3. Se construye un prototipo
    
    Duraci√≥n: Entre pocas semanas a pocos meses
    
2. **Planificaci√≥n**
    1. El cliente establece la prioridad de cada historia de usuario
    2. Los programadores realizan una estimaci√≥n del esfuerzo
    3. Se toman acuerdos sobre el contenido de la primera entrega y se determinaun cronograma conjunto con el cliente
    
    Duraci√≥n: Unos pocos d√≠as
    
3. **Iteraciones**
    1. El Plan de Entrega est√° compuesto por iteraciones de no m√°s de tres semanas
    2. El cliente es quien decide qu√© historias se implementan en cada iteraci√≥n
    3. Al final de la √∫ltima iteraci√≥n el sistema est√° listo para la producci√≥n
    
    Duraci√≥n: tres semanas por iteraci√≥n x cantidad de iteraciones
    
4. **Producci√≥n**
    1. Requiere de pruebas adicionales y revisiones de rendimiento antes de trasladar el sistema al entorno del cliente
    2. Se deben tomar decisiones sobre la inclusi√≥n de nuevas caracter√≠sticas a la versi√≥n actual
5. **Mantenimiento**
    1. Mientras la primera versi√≥n se encuentra en producci√≥n, el proyecto debe mantener el sistema funcionando al mismo tiempo que desarrolla nuevas iteraciones
    2. La fase de mantenimiento puede requerir nuevo personal
6. **Muerte**
    1. Es cuando el cliente no tiene m√°s historias para ser incluidas
    2. Se genera la documentaci√≥n final del sistema
    3. Tambi√©n ocurre cuando el sistema no genera los beneficios esperados o no hay presupuesto

******************Pr√°cticas****************** 

- **Testing:** Los programadores continuamente escriben pruebas unitarias
- **Refractoring**: Actividad constante de reestructuraci√≥n del c√≥digo para remover duplicaciones, simplificar, mejorar legibilidad y hacerlo m√°s flexible a nuevos cambios
- **Programaci√≥n de a pares**: Todo el c√≥digo de producci√≥n es escrito por dos programadores en una m√°quina
- **Propiedad colectiva del c√≥digo**: Cualquiera puede cambiar el c√≥digo en cualquier momento
- **Integraci√≥n continua**: Cada pieza de c√≥digo es integrada en el sistema una vez que est√° lista. Reduce la fragmentaci√≥n de los esfuerzos de los desarrolladores por falta de comunicaci√≥n sobre lo que puede ser reutilizado o compartido
- **Semana de 40 horas**: Se debe trabajar un m√°ximo de 40 horas por semana
- **Cliente en lugar de desarrollo**: El cliente tiene que estar presente y disponible todo el tiempo para el equipo
- **Est√°ndares de codificaci√≥n**: Los programadores escriben todo el c√≥digo de acuerdo con reglas que enfatizan la comunicaci√≥n a trav√©s del mismo

### 5.1.2. Scrum

Es un proceso en el que se aplican, de manera regular, un conjunto de mejores pr√°cticas para trabajar en equipo y obtener el mejor resultado posible de un proyecto

Se basa en ************************************************************entregas parciales y regulares************************************************************ del resultado final del proyecto, priorizadas por el beneficio que aportan al receptor del proyecto

********************Principios******************** 

- **Eliminar desperdicio:** No generar artefactos o perder tiempo con cosas que no suman valor
- **Construir la calidad con el producto:** Inyectar la calidad al c√≥digo desde el inicio
- **Crear conocimiento:** En la pr√°ctica no se puede tener conocimiento antes de desarrollar
- **Diferir las decisiones:** Tomar decisiones en el momento adecuado, si se puede esperar mejor
- **Entregar r√°pido:** Una de las ventajas m√°s importantes
- **Respetar a las personas**
- **Optimizar el todo**

**********Roles********** 

- **Product Owner**: Conoce y marca las prioridades del proyecto
- **Scrum Master**: Se asegura del seguimiento de la metodolog√≠a guiando las reuniones y ayudando al equipo
- **Scrum Team**: Responsables de implementar la funcionalidad elegida por el Product Owner
- **Usuarios o cliente**: Beneficiarios finalesdel producto, pueden aportar ideas o necesidades

********************Artefactos******************** 

![Untitled](Untitled%2025.png)

- **Product Backlog**: Una lista maestra que tiene todas las funcionalidades deseadas del producto ordenadas por prioridad
- **Sprint Backlog**: Una lista que tiene todas las funcionalidades que el equipo se comprometi√≥ a desarrollar en un Sprint determinado
- **Burndown Chart**: Muestra un acumulativo del trabajo hecho d√≠a a d√≠a
- etc

**************Proceso**************

Es iterativo e incremental, se busca poder atacar todos los problemas que surgen durante el desarrollo del proyecto

El nombre **********Scrum********** se debe a que los Sprints se solapan, de manera que no es un proceso en cascada, sino un mont√≥n de etapas juntas que se ejecutan una y otra vez

Est√° pensado para ser aplicado en proyectos donde el caos es una constante, con requerimientos din√°micos e implementaci√≥n de tecnolog√≠a de punta

# 6. Calidad

La **************calidad**************es una propiedad mensurable que puede ser juzgada; sin embargo, su significado es ambig√ºo y su uso depende de lo que cada uno entiende por calidad. No necesariamente refiere a un producto de lujo, ni se origina en el departamento de calidad

<aside>
ü§ñ Las principales normas internacionales definen la **calidad** como el grado en el que un conjunto de caracter√≠sticas inherentes cumple con los requisitos (ISO 9000)

</aside>

> ‚ÄúConjunto de propiedades o caracter√≠sticas de un producto o servicio que le confieren aptitud para satisfacer unas necesidades expresadas o impl√≠citas‚Äù (ISO 8402)
> 

---

Una **norma** es un documento establecido por conseso y aprobado por un organismo reconocido que proporciona un uso com√∫n y repetido, una serie de reglas, directrices o caracter√≠sticas.

La **Organizaci√≥n Internacional de Normalizaci√≥n** (ISO) es una organizaci√≥n para la creaci√≥n de est√°ndares o normas internacionales compuesta por dversas organizaciones nacionales de normalizaci√≥n.

## 6.1. Calidad de los sistemas de informaci√≥n

La importancia de los sist. de informaci√≥n (SI) en la actualidad hace necesario que las empresas de tecnolog√≠a hagan hincapi√© en los est√°ndares (o normas) de calidad. Se debe apreciar la calidad desde un todo, donde cada parte que la compone debe tener su propio an√°lisis de calidad

************************Componentes************************

![Visi√≥n Hol√≠stica de la calidad - Stylianou y Kumar (200)](Untitled%2026.png)

Visi√≥n Hol√≠stica de la calidad - Stylianou y Kumar (200)

******************************************Calidad de la empresa******************************************

- Calidad de los procesos de negocio soportados por SI
- **Calidad de SI**
    - **Calidad de la infraestructura**: incluye la calidad de las redes y sistemas de sw.
    - **Calidad de la gesti√≥n**: incluye el presupuesto, planificaci√≥n y programaci√≥n
    - **Calidad del software**: incluye los procesos de atenci√≥n al cliente
    - **Calidad de la informaci√≥n**: est√° relacionada con la calidad de los datos
    - **Calidad de datos**: los datos que ingresan en el sistema de informaci√≥n
    - **Calidad del servicio**: de las aplicaciones de sw. construidas o mantenidas, con el apoyo de IS

## 6.2. Calidad de software

La **calidiad de software** se ha mejorado en los √∫ltimos a√±os, en particular por una mayor conciencia de la gesti√≥n de la calidad y la adopci√≥n de t√©cnicas de gesti√≥n de calidad para el desarrollo en la insdustria de software.

Se divide en dos partes dependientes entre ellas:

- **Calidad del producto obtenido**: la estandarizaci√≥n del producto define las propiedades que debe satisfacer el producto de software resultante
- **Calidad del proceso de desarrollo**: la estandaricaci√≥n del proceso define la manera de desarrollar el producto de software

---

********Sin un buen proceso de desarrollo es casi imposible obtener un buen producto********

## 6.3. Norma/Modelo de calidad

### 6.3.1. **Norma de Calidad SQuaRE ISO/IEC 25000**

*ISO/IEC 25000 SQuaRE Software product Quality Requeriment and Evaluation*

SQuaRE cubre tres procesos de calidad complementarios:

- Especificaci√≥n de requisitos
- Metricas
- Evaluaci√≥n

![Untitled](Untitled%2027.png)

- **Divisi√≥n de Modelos de Calidad (2501n):** Modelo de calidad detallado incluyendo caracter√≠sticas para calidad interna y externa y la calidad de datos
- **Divisi√≥n de Gesti√≥n de Calidad (2500n):** Las normas que forman este apartado definen todos los modelos, t√©rminos y definiciones comunes referenciados por toda la serie SQuaRE
- **Divisi√≥n de Medici√≥n de Calidad (2502n):** Modelo de referencia de la medici√≥n de calidad del producto, definiciones de medidas de calidad y gu√≠as pr√°cticas de su uso
- **Divisi√≥n de Requisitos de calidad (2503n):** Ayuda a especificar los requisitos de calidad que pueden ser usados en el proceso de elicitaci√≥n
- **Divisi√≥n de Evaluaci√≥n de Calidad (2504n):** Requisitos, recomendaciones y gu√≠as para la evaluaci√≥n de producto

### 6.3.2. Norma de Calidad de software

![Untitled](Untitled%2028.png)

- **ISO/IEC 12207** ‚Äî Establece un modelo de procesos para el ciclo de vida del software
- **IDO/IEC 15504** ‚Äî Es una norma internacional para establecer y mejorar la capacidad y madurez de los procesos de las organizaciones en la adquisici√≥n, desarrollo, evoluci√≥n y soporte de productos y servicios

### 6.3.3. CMM (1993) ‚Äî CMMI (2000)

- Modelo de evaluaci√≥n de los procesos de una organizaci√≥n
- Marco de referencia para desarrollar procesos efectivos
- Proporciona un marco estructurado para evaluar los procesos actuales de la organizaci√≥n, establecer prioridades de mejora e implementarlas
- En el 2000, el SEI public√≥ un nuevo modelo CMMI o ‚ÄúModelo de Capacidad y Madurez - Integraci√≥n‚Äù con el objetivo de integrar distintos modelos

********CMMI********

Posee dos vistas que permiten un enfoque diferente seg√∫n las necesidades de qui√©n vaya a implementarlo:

**Escalonado**: Se centra en la madurez de la organizaci√≥n, al igual que CMM

![Untitled](Untitled%2029.png)

**Continuo**: Enfoca las actividades de mejora y evaluaci√≥n en la capacidad de los diferentes procesos. Presenta 6 niveles de capacidad, los cuales indican qu√© tan bien se desempe√±a la organizaci√≥n en un √°rea del proceso individual

![Untitled](Untitled%2030.png)

- Niveles de madurez
    1. **Inicial**: proceso impredecible, poco controlado y reactivo
    2. **Gestionado**: proceso caracterizado por proyectos y frecuentemente reactivo
    3. **Definido**: proceso caracterizado por la organizaci√≥n y proactivo
    4. **Gestionado Cuantitativamente**: el proceso es controlado cuantitativamente
    5. **Optimizado**: enfoque en la mejora del proceso

![Untitled](Untitled%2031.png)

## 6.4. Familia de las ISO 9000

- **ISO ‚Äî 900:2015** ‚Äî Quality managment system ‚Äî Requirements
    - Norma publicada por ISO en el a√±o 2015
- **IRAM ‚Äî ISO 9001:2015** ‚Äî Sistema de gesti√≥n de la calidad ‚Äî Requisitos
    - Norma publicada por ISO y traducida por IRAM
- **ISO 90003:2004**
    - Basada en ISO 9001:2000 (se espera una actualizaci√≥n para el pr√≥ximo a√±o)
    - Directrices para la interpretaci√≥n en el proceso de software.
        - Proporciona una gu√≠a para identificar las evidencias dentro del proceso de software para satisfacer los requisitos de la ISO 9001

### 6.4.1. Beneficios de trabajar con un sistema de gesti√≥n de calidad (SGC)

- ISO 9001 adegura que su negocio cumpla con los requisitos legales y del cliente
- Aumenta el rendimiento de su organizaci√≥n. El Sistema de Gesti√≥n de la Calidad ayuda a implementar procesos simplificados y mejorar la eficiencia operacional
- Asegura la toma de decisiones y mejora la satisfacci√≥n del cliente
- Optimiza sus operaciones para as√≠ cumplir y superar los requisitos de sus clientes
- Mejora su rendimiento financiero

### 6.4.2. SGC ‚Äî IRAM ‚Äî ISO 9001

SGC ‚Äî Mejora Continua

![Untitled](Untitled%2032.png)

## 6.5. Resumiendo

**Calidad de producto de software**

Se evalua la calidad mediante 

- ISO/IEC 25000
    - Est√° compuesto por distintos modelos.
    - Define caracter√≠sticas que pueden estar presentes o no el el producto.
    - La norma nos permite evaluar si est√°n presentes o no y c√≥mo evaluarlas
    - *Ej: seguridad, compatibilidad, etc*

**Calidad del proceso de desarrollo**

Se eval√∫a la calidad mediante:

- ISO/IEC 12207
    - Establece un modelo de procesos para el ciclo de vida del software
    - Define c√≥mo deber√≠a ser el modelo de proceso para ser completo y con calidad
    - Actividades, tareas, etc
- ISO/IEC 15504
    - Es una norma internacional para establecer y mejorar la capacidad y madurex de los procesos
    - Define qu√© se debe tener en cuanta para evaluar el modelo de proceso y concluir si es completo y con calidad
- ISO/IEC 90003
    - Proporciona una gu√≠a sobre c√≥mo aplicar la ISO 9001 en procesos de software
- CMMI
    - Proporciona un marco estructurado para evaluar procesos actuales de la organizaci√≥n, establecer prioridades de mejora e implementarlas
    - Se usa para organizaciones desarrolladoras de software de medianas a grandes dimensiones

**Calidad de Procesos/Servicios/Productos en general**

Se eval√∫a mediante

- ISO 9001
    - Determina los requisitos para establecer un Sistema de Gesti√≥n de la Calidad, de producto y/o servicio
    - Forma parte de la familia ISO 9000, que es un conjunto de normas de ‚Äúgesti√≥n de la calidad‚Äù aplicables a cualqueir tipo de organizaci√≥n con el objetivo de obtener mejoras en la organizaci√≥n y, eventualmente, arribar a una certificaci√≥n